#           gsub("[^[:digit:]]", "", .)
#         )))==5
#       ) & all(
#         unique(nchar(na.omit(
#           v %>%
#           word(2) %>%
#           gsub("[[:digit:]]", "", .)
#         )))==0
#       )
#     ){
#       v <- word(v, 1)
#       v <- lubridate::date(janitor::excel_numeric_to_date(as.numeric(v)))
#     }
#     v
#   }
}
#' Samantha Rhoads's function to extract or keep or select elements of a VECTOR. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_vec2 <- function(v, pattern=".*", ignore.case=T, everything=F, invert=F){
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
tv <- tryCatch(tibble::as_tibble(t(tibble::as_tibble(v))) %>% setNames(v), error=function(e) v)
tv <- tryCatch({
if(everything){
if(invert) {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
}
} else {
if(invert) {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern))) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()    }
}
tv
},
error=function(e){
if(!is.null(names(tv))){
tv <- tv %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
tv <- tv %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
}
tv
})
tv
}
matches
dplyr::matches
#' Samantha Rhoads's function to extract or keep or select elements of a VECTOR. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_vec2 <- function(v, pattern=".*", ignore.case=T, everything=F, invert=F){
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
tv <- tryCatch(tibble::as_tibble(t(tibble::as_tibble(v))) %>% setNames(v), error=function(e) v)
tv <- tryCatch({
if(everything){
if(invert) {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern), ignore.case = ignore.case), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern), ignore.case = ignore.case), dplyr::everything()) %>% names()
}
} else {
if(invert) {
tv <- tv %>% dplyr::select(-dplyr::matches(paste_regex(pattern), ignore.case = ignore.case)) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), ignore.case = ignore.case) %>% names()    }
}
tv
},
error=function(e){
if(!is.null(names(tv))){
tv <- tv %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
tv <- tv %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
}
tv
})
tv
}
plusorminus
#' Samantha Rhoads's function to extract or keep or select elements of a list, dataframe, or vector with a regular expression. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_matches <- select_list_or_other <- function(x, pat=".*", invert=F, ignore.case=F){
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
}
#' Samantha Rhoads's function to do `setdiff()` from both sides and print which input the different strings come from
#' @export
#' @examples
#' reticulate_correctly(x, y, printWhichOnly=F)
reticulate_correctly <- function(){
reticulate::use_python("/usr/local/bin/python3", required = TRUE)
reticulate::repl_python()
}
reticulate_correctly()
roxygen2::roxygenise(clean = TRUE)
devtools::document() # roxygen2::roxygenise(clean = TRUE)
word
stringr::word
tidyverse_packages
tidyverse::tidyverse_packages()
devtools::document() # roxygen2::roxygenise(clean = TRUE)
roxygen2::roxygenise(clean = TRUE)
devtools::document() # roxygen2::roxygenise(clean = TRUE)
system('git add -A && git commit -m "new functions added/edited- reticulate_correctly()"; git push') ### --- SHELL if you remove system()
devtools::install_github('srhoads/srhoads')
roxygen2::roxygenise(clean = TRUE)
devtools::document() # roxygen2::roxygenise(clean = TRUE)
roxygen2::roxygenise(clean = TRUE)
devtools::document() # roxygen2::roxygenise(clean = TRUE)
system('git add -A && git commit -m "remove anything with glmnet or text2vec"; git push') ### --- SHELL if you remove system()
devtools::install_github('srhoads/srhoads')
arrange
dplyr::arrange
`%>%` <- magrittr::`%>%`
`%<>%` <- magrittr::`%<>%`
`%<>%`
# --------------------------------------------
if("magrittr" %in% installed.packages()){
`%>%` <- magrittr::`%>%`
`%<>%` <- magrittr::`%<>%`
}
`%>%`
roxygen2::roxygenise(clean = TRUE)
devtools::document()
roxygen2::roxygenise(clean = TRUE)
devtools::document()
system('git add -A && git commit -m "assigned some more functions to their :: packages + assigned pipes globally"; git push') ### --- SHELL if you remove system()
devtools::install_github('srhoads/srhoads')
x <- dfsample %>% list()
x
x <- dfsample %>% as.list()
x
dfsampler() %>% as.list()
iris %>% as.list()
x <- iris %>% as.list(); select_matches(x, pat="Petal")
#' Samantha Rhoads's function to extract or keep or select elements of a list, dataframe, or vector with a regular expression. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples x <- iris %>% as.list(); select_matches(x, pat="Petal")
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_matches <- select_list_or_other <- function(x, pat=".*", invert=F, ignore.case=F){
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% purrr:keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
}
x <- iris %>% as.list(); select_matches(x, pat="Petal")
#' Samantha Rhoads's function to extract or keep or select elements of a list, dataframe, or vector with a regular expression. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples x <- iris %>% as.list(); select_matches(x, pat="Petal")
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_matches <- select_list_or_other <- function(x, pat=".*", invert=F, ignore.case=F){
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% purrr::keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
}
x <- iris %>% as.list(); select_matches(x, pat="Petal")
x
v <- iris$Species
v <- iris$Species; select_matches(x, pat="versi")
select_matches(x, pat="versi")
v <- iris$Species; select_matches(v, pat="versi")
invert=F
ignore.case=F
pat="versi"
x <- v
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
is.vector(x)
x
class(x)
is.vector(x)
is.factorchar(x)
is.factorchar(iris)
is.factorchar(as.list(iris))
is.vector(x)|is.factorchar(x)
depth(x)
depth(iris)
depth(as.list(iris))
depth(iris$Sepal.Length)
depth(iris$Sepal.Length[1])
x
xx <- x %>% setNames(x)
xx
names(xx)
depth(xx)==0
depth(xx)
xx <- x %>% unlist() %>% as.character() %>% setNames(x)
xx
depth(xx)==0
#' Samantha Rhoads's function to extract or keep or select elements of a list, dataframe, or vector with a regular expression. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples x <- as.list(iris); select_matches(x, pat="Petal"); v <- iris$Species; select_matches(v, pat="versi")
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_matches <- select_list_or_other <- function(x, pat=".*", invert=F, ignore.case=F){
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% purrr::keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)|is.factorchar(x)|depth(x)==0){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
}
v <- iris$Species; select_matches(v, pat="versi")
list(v)
x <- list(v)
select_matches(x, pat="Petal")
select_matches(x, pat="versi")
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% purrr::keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)|is.factorchar(x)|depth(x)==0){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
is.list(x)
is.list(x)&!is.data.frame(x)
x %>% purrr::keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
#' Samantha Rhoads's function to extract or keep or select elements of a list, dataframe, or vector with a regular expression. Invert means keep everything other than the pattern. Default pattern is everything
#' @export
#' @examples x <- as.list(iris); select_matches(x, pat="Petal"); v <- iris$Species; select_matches(v, pat="versi")
#' select_matches(x, pat=".*", invert=F, ignore.case=F)
select_matches <- select_list_or_other <- function(x, pat=".*", invert=F, ignore.case=F){
pattern <- pat
`%>%` <- magrittr::`%>%`
if(invert) {yesornot <- `!`; plusorminus <- `-`} else {yesornot <- function(x) x; plusorminus <- function(x) x}
# if(invert) {yesornot <- function(y) `!`; plusorminus <- function(y) `-`} else {yesornot <- function(y) ``; plusorminus <- function(y) ``}
if(is.list(x)&!is.data.frame(x)){
x %>% purrr::keep(yesornot(grepl(pat, names(.), ignore.case = ignore.case)))
} else if(is.data.frame(x)){
x %>% dplyr::select(plusorminus(dplyr::matches(pat, ignore.case = ignore.case)))
} else if(is.vector(x)|is.factorchar(x)|depth(x)==0){
if(!is.null(names(x))){
x %>% purrr::keep(yesornot(grepl(pattern, names(.), ignore.case = ignore.case))) %>% names()
} else {
x %>% purrr::keep(yesornot(grepl(pattern, ., ignore.case = ignore.case)))
} # x %>% select_vec2(., pattern=pat, invert=invert, ignore.case=ignore.case)
} else {
print("object doesn't match anything for select_matches() to work on")
x
}
}
tibble::as_tibble
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- tibble::as_tibble(t(tibble::as_tibble(v))) %>% setNames(v)
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv
}
select_vec(iris$Species, pattern="versi")
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% make.unique(., sep=""))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv
}
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% make.unique(., sep=""))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv
}
select_vec(iris$Species, pattern="versi")
v <- iris$Species
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
as_tibble(t(as_tibble(v)))
as_tibble(t(as_tibble(v))) %>% setNames(v %>% make.unique(., sep=""))
v %>% make.unique(., sep="")
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep=""))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv
}
select_vec(iris$Species, pattern="versi")
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep="~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY"))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv %>% gsub("~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY.*", "", .)
}
select_vec(iris$Species, pattern="versi")
select_matches(iris$Species, pattern="versi")
select_matches(iris$Species, pat="versi")
tv0 %>% factor(., levels=levels(v))
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep="~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY"))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
everything=F
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep="~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY"))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv0 <- tv %>% gsub("~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY.*", "", .)
if(is.factor(v)){
tv0 %>% factor(., levels=levels(v))
}
select_matches(as.character(iris$Species), pat="versi")
select_vec(as.character(iris$Species), pattern="versi")
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep="~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY"))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv0 <- tv %>% gsub("~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY.*", "", .)
if(is.factor(v)){
tv0 <- tv0 %>% factor(., levels=levels(v))
}
tv0
}
rm(list=ls())
#' Samantha Rhoads's function to...
#'
#' Srhoads wrote this to allow you to...
#' @export
#' @examples
#' select_vec()
select_vec <- function(v, pattern, ignore.case=T, everything=F){
as_tibble <- function(x, ..., .rows = NULL, .name_repair = c("check_unique", "unique", "universal", "minimal"), rownames = pkgconfig::get_config("tibble::rownames", NULL)){
suppressWarnings(tibble::as_tibble(x, ..., .rows, .name_repair, rownames))
}
tv <- as_tibble(t(as_tibble(v))) %>% setNames(v %>% as.character() %>% make.unique(., sep="~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY"))
if(everything){
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern)), dplyr::everything()) %>% names()
} else {
tv <- tv %>% dplyr::select(dplyr::matches(paste_regex(pattern))) %>% names()
}
tv0 <- tv %>% gsub("~FUNKYDISTINCTIVEPATTERN~~MEOW~~920482033243931~~~BDJKSFH~SAMISRHOADSY.*", "", .)
if(is.factor(v)){
tv0 <- tv0 %>% factor(., levels=levels(v))
}
tv0
}
select_matches(as.character(iris$Species), pat="versi")
select_vec(as.character(iris$Species), pattern="versi")
select_vec((iris$Species), pattern="versi")
select_matches((iris$Species), pat="versi")
select_matches(iris$Species, pat="versi")
duplicated
one_of
dplyr::one_of
vars
dplyr::vars
#' A function that can filter a dataframe so it includes all duplicates of your variable of choice
#'
#' This function allows you to
#' @export
#' @examples
#' filter_duplicated()
filter_duplicated <- function(d, var="id"){
vdups <-  d %>% dplyr::filter_at(dplyr::vars(dplyr::one_of(var)), function(v) duplicated(v)) %>% .[[var]]
d %>% dplyr::filter_at(dplyr::vars(dplyr::one_of("id")), function(v) v %in% vdups)
}
